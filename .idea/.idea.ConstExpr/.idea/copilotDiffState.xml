<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/SourceGen.Utilities/Helpers/IndentedCodeWriter.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SourceGen.Utilities/Helpers/IndentedCodeWriter.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Collections.Immutable;&#10;using System.ComponentModel;&#10;using System.Globalization;&#10;using System.Runtime.CompilerServices;&#10;using System.Text;&#10;using Microsoft.CodeAnalysis;&#10;using Microsoft.CodeAnalysis.Text;&#10;using System.Threading;&#10;&#10;namespace SourceGen.Utilities.Helpers;&#10;&#10;/// &lt;summary&gt;&#10;/// A helper type to build sequences of values with pooled buffers.&#10;/// &lt;/summary&gt;&#10;public sealed class IndentedCodeWriter : IDisposable&#10;{&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// The default indentation (tab).&#10;&#9;/// &lt;/summary&gt;&#10;&#9;private const string DefaultIndentation = &quot;\t&quot;;&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// The default new line (&lt;c&gt;'\n'&lt;/c&gt;).&#10;&#9;/// &lt;/summary&gt;&#10;&#9;private const char DefaultNewLine = '\n';&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// The &lt;see cref=&quot;ImmutableArrayBuilder{T}&quot;/&gt; instance that text will be written to.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;private ImmutableArrayBuilder&lt;char&gt; _builder;&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// The current indentation level.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;private int _currentIndentationLevel;&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// The current indentation, as text.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;private string _currentIndentation = String.Empty;&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// The cached array of available indentations, as text.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;private string[] _availableIndentations;&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Creates a new &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; object.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;public IndentedCodeWriter()&#10;&#9;{&#10;&#9;&#9;_builder = new ImmutableArrayBuilder&lt;char&gt;();&#10;&#9;&#9;_currentIndentationLevel = 0;&#10;&#9;&#9;_currentIndentation = String.Empty;&#10;&#9;&#9;_availableIndentations = new string[4];&#10;&#9;&#9;_availableIndentations[0] = String.Empty;&#10;&#10;&#9;&#9;for (int i = 1, n = _availableIndentations.Length; i &lt; n; i++)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_availableIndentations[i] = _availableIndentations[i - 1] + DefaultIndentation;&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Advances the current writer and gets a &lt;see cref=&quot;Span{T}&quot;/&gt; to the requested memory area.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;requestedSize&quot;&gt;The requested size to advance by.&lt;/param&gt;&#10;&#9;/// &lt;returns&gt;A &lt;see cref=&quot;Span{T}&quot;/&gt; to the requested memory area.&lt;/returns&gt;&#10;&#9;/// &lt;remarks&gt;&#10;&#9;/// No other data should be written to the writer while the returned &lt;see cref=&quot;Span{T}&quot;/&gt;&#10;&#9;/// is in use, as it could invalidate the memory area wrapped by it, if resizing occurs.&#10;&#9;/// &lt;/remarks&gt;&#10;&#9;public Span&lt;char&gt; Advance(int requestedSize)&#10;&#9;{&#10;&#9;&#9;// Add the leading whitespace if needed (same as WriteRawText below)&#10;&#9;&#9;if (_builder.Count == 0 || _builder.WrittenSpan[^1] == DefaultNewLine)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_builder.AddRange(_currentIndentation.AsSpan());&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return _builder.Advance(requestedSize);&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Increases the current indentation level.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;public void IncreaseIndent()&#10;&#9;{&#10;&#9;&#9;_currentIndentationLevel++;&#10;&#10;&#9;&#9;if (_currentIndentationLevel == _availableIndentations.Length)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Array.Resize(ref _availableIndentations, _availableIndentations.Length * 2);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Set both the current indentation and the current position in the indentations&#10;&#9;&#9;// array to the expected indentation for the incremented level (ie. one level more).&#10;&#9;&#9;_currentIndentation = _availableIndentations[_currentIndentationLevel]&#10;&#9;&#9;&#9;??= _availableIndentations[_currentIndentationLevel - 1] + DefaultIndentation;&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Decreases the current indentation level.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;public void DecreaseIndent()&#10;&#9;{&#10;&#9;&#9;_currentIndentationLevel--;&#10;&#9;&#9;_currentIndentation = _availableIndentations[_currentIndentationLevel];&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes a block to the underlying buffer.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;start&quot;&gt;The opening string to use for the block.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;end&quot;&gt;The closing string to use for the block.&lt;/param&gt;&#10;&#9;/// &lt;returns&gt;A &lt;see cref=&quot;Block&quot;/&gt; value to close the open block with.&lt;/returns&gt;&#10;&#9;public Block WriteBlock(string start = &quot;{&quot;, string end = &quot;}&quot;)&#10;&#9;{&#10;&#9;&#9;WriteLine(start);&#10;&#9;&#9;IncreaseIndent();&#10;&#10;&#9;&#9;return new Block(this, end);&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;content&quot;&gt;The content to write.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;isMultiline&quot;&gt;Whether the input content is multiline.&lt;/param&gt;&#10;&#9;public void Write(string content, bool isMultiline = false)&#10;&#9;{&#10;&#9;&#9;Write(content.AsSpan(), isMultiline);&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;content&quot;&gt;The content to write.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;isMultiline&quot;&gt;Whether the input content is multiline.&lt;/param&gt;&#10;&#9;public void Write(ReadOnlySpan&lt;char&gt; content, bool isMultiline = false)&#10;&#9;{&#10;&#9;&#9;if (isMultiline)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;while (content.Length &gt; 0)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;var newLineIndex = content.IndexOf(DefaultNewLine);&#10;&#10;&#9;&#9;&#9;&#9;if (newLineIndex &lt; 0)&#10;&#9;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;&#9;// There are no new lines left, so the content can be written as a single line&#10;&#9;&#9;&#9;&#9;&#9;WriteRawText(content);&#10;&#10;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;var line = content[..newLineIndex];&#10;&#10;&#9;&#9;&#9;&#9;// Write the current line (if it's empty, we can skip writing the text entirely).&#10;&#9;&#9;&#9;&#9;// This ensures that raw multiline string literals with blank lines don't have&#10;&#9;&#9;&#9;&#9;// extra whitespace at the start of those lines, which would otherwise happen.&#10;&#9;&#9;&#9;&#9;WriteIf(!line.IsEmpty, line);&#10;&#9;&#9;&#9;&#9;WriteLine();&#10;&#10;&#9;&#9;&#9;&#9;// Move past the new line character (the result could be an empty span)&#10;&#9;&#9;&#9;&#9;content = content[(newLineIndex + 1)..];&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;else&#10;&#9;&#9;{&#10;&#9;&#9;&#9;WriteRawText(content);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;handler&quot;&gt;The interpolated string handler with content to write.&lt;/param&gt;&#10;&#9;public void Write([InterpolatedStringHandlerArgument(&quot;&quot;)] ref WriteInterpolatedStringHandler handler)&#10;&#9;{&#10;&#9;&#9;_ = this;&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer depending on an input condition.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;condition&quot;&gt;The condition to use to decide whether or not to write content.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;content&quot;&gt;The content to write.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;isMultiline&quot;&gt;Whether the input content is multiline.&lt;/param&gt;&#10;&#9;public void WriteIf(bool condition, string content, bool isMultiline = false)&#10;&#9;{&#10;&#9;&#9;if (condition)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Write(content.AsSpan(), isMultiline);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer depending on an input condition.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;condition&quot;&gt;The condition to use to decide whether or not to write content.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;content&quot;&gt;The content to write.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;isMultiline&quot;&gt;Whether the input content is multiline.&lt;/param&gt;&#10;&#9;public void WriteIf(bool condition, ReadOnlySpan&lt;char&gt; content, bool isMultiline = false)&#10;&#9;{&#10;&#9;&#9;if (condition)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Write(content, isMultiline);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer depending on an input condition.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;condition&quot;&gt;The condition to use to decide whether or not to write content.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;handler&quot;&gt;The interpolated string handler with content to write.&lt;/param&gt;&#10;&#9;public void WriteIf(bool condition, [InterpolatedStringHandlerArgument(&quot;&quot;, nameof(condition))] ref WriteIfInterpolatedStringHandler handler)&#10;&#9;{&#10;&#9;&#9;_ = this;&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes a line to the underlying buffer.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;skipIfPresent&quot;&gt;Indicates whether to skip adding the line if there already is one.&lt;/param&gt;&#10;&#9;public void WriteLine(bool skipIfPresent = false)&#10;&#9;{&#10;&#9;&#9;if (skipIfPresent &amp;&amp; _builder.WrittenSpan is [ .., '\n', '\n' ])&#10;&#9;&#9;{&#10;&#9;&#9;&#9;return;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;_builder.Add(DefaultNewLine);&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer and appends a trailing new line.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;content&quot;&gt;The content to write.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;isMultiline&quot;&gt;Whether the input content is multiline.&lt;/param&gt;&#10;&#9;public void WriteLine(string content, bool isMultiline = false)&#10;&#9;{&#10;&#9;&#9;WriteLine(content.AsSpan(), isMultiline);&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer and appends a trailing new line.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;content&quot;&gt;The content to write.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;isMultiline&quot;&gt;Whether the input content is multiline.&lt;/param&gt;&#10;&#9;public void WriteLine(ReadOnlySpan&lt;char&gt; content, bool isMultiline = false)&#10;&#9;{&#10;&#9;&#9;Write(content, isMultiline);&#10;&#9;&#9;WriteLine();&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer and appends a trailing new line.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;handler&quot;&gt;The interpolated string handler with content to write.&lt;/param&gt;&#10;&#9;public void WriteLine([InterpolatedStringHandlerArgument(&quot;&quot;)] ref WriteInterpolatedStringHandler handler)&#10;&#9;{&#10;&#9;&#9;WriteLine();&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes a line to the underlying buffer depending on an input condition.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;condition&quot;&gt;The condition to use to decide whether or not to write content.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;skipIfPresent&quot;&gt;Indicates whether to skip adding the line if there already is one.&lt;/param&gt;&#10;&#9;public void WriteLineIf(bool condition, bool skipIfPresent = false)&#10;&#9;{&#10;&#9;&#9;if (condition)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;WriteLine(skipIfPresent);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer and appends a trailing new line depending on an input condition.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;condition&quot;&gt;The condition to use to decide whether or not to write content.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;content&quot;&gt;The content to write.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;isMultiline&quot;&gt;Whether the input content is multiline.&lt;/param&gt;&#10;&#9;public void WriteLineIf(bool condition, string content, bool isMultiline = false)&#10;&#9;{&#10;&#9;&#9;if (condition)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;WriteLine(content.AsSpan(), isMultiline);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer and appends a trailing new line depending on an input condition.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;condition&quot;&gt;The condition to use to decide whether or not to write content.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;content&quot;&gt;The content to write.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;isMultiline&quot;&gt;Whether the input content is multiline.&lt;/param&gt;&#10;&#9;public void WriteLineIf(bool condition, ReadOnlySpan&lt;char&gt; content, bool isMultiline = false)&#10;&#9;{&#10;&#9;&#9;if (condition)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Write(content, isMultiline);&#10;&#9;&#9;&#9;WriteLine();&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer and appends a trailing new line depending on an input condition.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;condition&quot;&gt;The condition to use to decide whether or not to write content.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;handler&quot;&gt;The interpolated string handler with content to write.&lt;/param&gt;&#10;&#9;public void WriteLineIf(bool condition, [InterpolatedStringHandlerArgument(&quot;&quot;, nameof(condition))] ref WriteIfInterpolatedStringHandler handler)&#10;&#9;{&#10;&#9;&#9;if (condition)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;WriteLine();&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;inheritdoc/&gt;&#10;&#9;public override string ToString()&#10;&#9;{&#10;&#9;&#9;return _builder.WrittenSpan.Trim().ToString();&#10;&#9;}&#10;&#9;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Creates a &lt;see cref=&quot;SourceText&quot;/&gt; instance from the current content of the writer.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;returns&gt;A &lt;see cref=&quot;SourceText&quot;/&gt; instance containing the written content.&lt;/returns&gt;&#10;&#9;public SourceText ToSourceText()&#10;&#9;{&#10;&#9;&#9;return new IndentedCodeWriterSourceText(_builder, Encoding.UTF8);&#10;&#9;}&#10;&#10;&#9;/// &lt;inheritdoc/&gt;&#10;&#9;public void Dispose()&#10;&#9;{&#10;&#9;&#9;_builder.Dispose();&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes raw text to the underlying buffer, adding leading indentation if needed.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;content&quot;&gt;The raw text to write.&lt;/param&gt;&#10;&#9;private void WriteRawText(ReadOnlySpan&lt;char&gt; content)&#10;&#9;{&#10;&#9;&#9;if (_builder.Count == 0 || _builder.WrittenSpan[^1] == DefaultNewLine)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_builder.AddRange(_currentIndentation.AsSpan());&#10;&#9;&#9;}&#10;&#10;&#9;&#9;_builder.AddRange(content);&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// A delegate representing a callback to write data into an &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; instance.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;typeparam name=&quot;T&quot;&gt;The type of data to use.&lt;/typeparam&gt;&#10;&#9;/// &lt;param name=&quot;value&quot;&gt;The input data to use to write into &lt;paramref name=&quot;writer&quot;/&gt;.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;writer&quot;&gt;The &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; instance to write into.&lt;/param&gt;&#10;&#9;public delegate void Callback&lt;in T&gt;(T value, IndentedCodeWriter writer);&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Represents an indented block that needs to be closed.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;writer&quot;&gt;The input &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; instance to wrap.&lt;/param&gt;&#10;&#9;public struct Block(IndentedCodeWriter writer, string ending) : IDisposable&#10;&#9;{&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// The &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; instance to write to.&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;private IndentedCodeWriter? _writer = writer;&#10;&#10;&#9;&#9;/// &lt;inheritdoc/&gt;&#10;&#9;&#9;public void Dispose()&#10;&#9;&#9;{&#10;&#9;&#9;&#9;var writer = _writer;&#10;&#10;&#9;&#9;&#9;_writer = null;&#10;&#10;&#9;&#9;&#9;if (writer is not null)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;writer.DecreaseIndent();&#10;&#9;&#9;&#9;&#9;writer.WriteLine(ending);&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Provides a handler used by the language compiler to append interpolated strings into &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; instances.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;[EditorBrowsable(EditorBrowsableState.Never)]&#10;&#9;[InterpolatedStringHandler]&#10;&#9;public readonly ref struct WriteInterpolatedStringHandler&#10;&#9;{&#10;&#9;&#9;/// &lt;summary&gt;The associated &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; to which to append.&lt;/summary&gt;&#10;&#9;&#9;private readonly IndentedCodeWriter _writer;&#10;&#10;&#9;&#9;/// &lt;summary&gt;Creates a handler used to append an interpolated string into a &lt;see cref=&quot;StringBuilder&quot;/&gt;.&lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;literalLength&quot;&gt;The number of constant characters outside of interpolation expressions in the interpolated string.&lt;/param&gt;&#10;&#9;&#9;/// &lt;param name=&quot;formattedCount&quot;&gt;The number of interpolation expressions in the interpolated string.&lt;/param&gt;&#10;&#9;&#9;/// &lt;param name=&quot;writer&quot;&gt;The associated &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; to which to append.&lt;/param&gt;&#10;&#9;&#9;/// &lt;remarks&gt;This is intended to be called only by compiler-generated code. Arguments are not validated as they'd otherwise be for members intended to be used directly.&lt;/remarks&gt;&#10;&#9;&#9;public WriteInterpolatedStringHandler(int literalLength, int formattedCount, IndentedCodeWriter writer)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_writer = writer;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;Writes the specified string to the handler.&lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;value&quot;&gt;The string to write.&lt;/param&gt;&#10;&#9;&#9;public void AppendLiteral(string value)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_writer.Write(value);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;Writes the specified value to the handler.&lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;value&quot;&gt;The value to write.&lt;/param&gt;&#10;&#9;&#9;public void AppendFormatted(string? value)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;AppendFormatted&lt;string?&gt;(value);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;Writes the specified character span to the handler.&lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;value&quot;&gt;The span to write.&lt;/param&gt;&#10;&#9;&#9;public void AppendFormatted(ReadOnlySpan&lt;char&gt; value)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_writer.Write(value);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;Writes the specified value to the handler.&lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;value&quot;&gt;The value to write.&lt;/param&gt;&#10;&#9;&#9;/// &lt;typeparam name=&quot;T&quot;&gt;The type of the value to write.&lt;/typeparam&gt;&#10;&#9;&#9;public void AppendFormatted&lt;T&gt;(T value)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;if (value is not null)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;_writer.Write(value.ToString());&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;Writes the specified value to the handler.&lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;value&quot;&gt;The value to write.&lt;/param&gt;&#10;&#9;&#9;/// &lt;param name=&quot;format&quot;&gt;The format string.&lt;/param&gt;&#10;&#9;&#9;/// &lt;typeparam name=&quot;T&quot;&gt;The type of the value to write.&lt;/typeparam&gt;&#10;&#9;&#9;public void AppendFormatted&lt;T&gt;(T value, string? format)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;if (value is IFormattable formattable)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;_writer.Write(formattable.ToString(format, CultureInfo.InvariantCulture));&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;else if (value is not null)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;_writer.Write(value.ToString());&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;Writes the specified parameter name to the handler.&lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;parameter&quot;&gt;The parameter symbol to write.&lt;/param&gt;&#10;&#9;&#9;public void AppendFormatted(IParameterSymbol parameter)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_writer.Write(parameter.Name);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Writes the specified parameter names to the handler.&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;parameters&quot;&gt;The parameter symbols to write.&lt;/param&gt;&#10;&#9;&#9;public void AppendFormatted(ImmutableArray&lt;IParameterSymbol&gt; parameters)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;for (var i = 0; i &lt; parameters.Length; i++)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;_writer.Write(parameters[i].Name);&#10;&#10;&#9;&#9;&#9;&#9;if (i &lt; parameters.Length - 1)&#10;&#9;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;&#9;_writer.Write(&quot;, &quot;);&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Provides a handler used by the language compiler to conditionally append interpolated strings into &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; instances.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;[EditorBrowsable(EditorBrowsableState.Never)]&#10;&#9;[InterpolatedStringHandler]&#10;&#9;public readonly ref struct WriteIfInterpolatedStringHandler&#10;&#9;{&#10;&#9;&#9;/// &lt;summary&gt;The associated &lt;see cref=&quot;WriteInterpolatedStringHandler&quot;/&gt; to use.&lt;/summary&gt;&#10;&#9;&#9;private readonly WriteInterpolatedStringHandler _handler;&#10;&#10;&#9;&#9;/// &lt;summary&gt;Creates a handler used to append an interpolated string into a &lt;see cref=&quot;StringBuilder&quot;/&gt;.&lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;literalLength&quot;&gt;The number of constant characters outside of interpolation expressions in the interpolated string.&lt;/param&gt;&#10;&#9;&#9;/// &lt;param name=&quot;formattedCount&quot;&gt;The number of interpolation expressions in the interpolated string.&lt;/param&gt;&#10;&#9;&#9;/// &lt;param name=&quot;writer&quot;&gt;The associated &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; to which to append.&lt;/param&gt;&#10;&#9;&#9;/// &lt;param name=&quot;condition&quot;&gt;The condition to use to decide whether or not to write content.&lt;/param&gt;&#10;&#9;&#9;/// &lt;param name=&quot;shouldAppend&quot;&gt;A value indicating whether formatting should proceed.&lt;/param&gt;&#10;&#9;&#9;/// &lt;remarks&gt;This is intended to be called only by compiler-generated code. Arguments are not validated as they'd otherwise be for members intended to be used directly.&lt;/remarks&gt;&#10;&#9;&#9;public WriteIfInterpolatedStringHandler(int literalLength, int formattedCount, IndentedCodeWriter writer, bool condition, out bool shouldAppend)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;if (condition)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;_handler = new WriteInterpolatedStringHandler(literalLength, formattedCount, writer);&#10;&#10;&#9;&#9;&#9;&#9;shouldAppend = true;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;else&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;_handler = default;&#10;&#10;&#9;&#9;&#9;&#9;shouldAppend = false;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;inheritdoc cref=&quot;WriteInterpolatedStringHandler.AppendLiteral(string)&quot;/&gt;&#10;&#9;&#9;public void AppendLiteral(string value)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_handler.AppendLiteral(value);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;inheritdoc cref=&quot;WriteInterpolatedStringHandler.AppendFormatted(string?)&quot;/&gt;&#10;&#9;&#9;public void AppendFormatted(string? value)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_handler.AppendFormatted(value);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;inheritdoc cref=&quot;WriteInterpolatedStringHandler.AppendFormatted(ReadOnlySpan{char})&quot;/&gt;&#10;&#9;&#9;public void AppendFormatted(ReadOnlySpan&lt;char&gt; value)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_handler.AppendFormatted(value);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;inheritdoc cref=&quot;WriteInterpolatedStringHandler.AppendFormatted{T}(T)&quot;/&gt;&#10;&#9;&#9;public void AppendFormatted&lt;T&gt;(T value)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_handler.AppendFormatted(value);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;inheritdoc cref=&quot;WriteInterpolatedStringHandler.AppendFormatted{T}(T, string?)&quot;/&gt;&#10;&#9;&#9;public void AppendFormatted&lt;T&gt;(T value, string? format)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_handler.AppendFormatted(value, format);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;inheritdoc cref=&quot;WriteInterpolatedStringHandler.AppendFormatted(IParameterSymbol)&quot;/&gt;&#10;&#9;&#9;public void AppendFormatted(IParameterSymbol parameter)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_handler.AppendFormatted(parameter);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;inheritdoc cref=&quot;WriteInterpolatedStringHandler.AppendFormatted(ImmutableArray{IParameterSymbol})&quot;/&gt;&#10;&#9;&#9;public void AppendFormatted(ImmutableArray&lt;IParameterSymbol&gt; parameters)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_handler.AppendFormatted(parameters);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// A specialized &lt;see cref=&quot;SourceText&quot;/&gt; implementation optimized for &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; content.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;private sealed class IndentedCodeWriterSourceText(ImmutableArrayBuilder&lt;char&gt; content, Encoding encoding) : SourceText&#10;&#9;{&#10;&#9;&#9;public override Encoding Encoding =&gt; encoding;&#10;&#10;&#9;&#9;public override int Length =&gt; content.Count;&#10;&#10;&#9;&#9;public override char this[int position]&#10;&#9;&#9;{&#10;&#9;&#9;&#9;get&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;if (position &lt; 0 || position &gt;= Length)&#10;&#9;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;&#9;throw new ArgumentOutOfRangeException(nameof(position));&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;return content.WrittenSpan[position];&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;public override string ToString()&#10;&#9;&#9;{&#10;&#9;&#9;&#9;return content.WrittenSpan.ToString();&#10;&#9;&#9;}&#10;&#10;&#9;&#9;public override string ToString(TextSpan span)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;if (span.Start &lt; 0 || span.Start &gt; Length || span.End &gt; Length)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;throw new ArgumentOutOfRangeException(nameof(span));&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;return content.WrittenSpan.Slice(span.Start, span.Length).ToString();&#10;&#9;&#9;}&#10;&#10;&#9;&#9;public override void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;if (sourceIndex &lt; 0 || sourceIndex &gt; Length)&#10;&#9;&#9;&#9;&#9;throw new ArgumentOutOfRangeException(nameof(sourceIndex));&#10;&#9;&#9;&#9;if (destinationIndex &lt; 0 || destinationIndex &gt; destination.Length)&#10;&#9;&#9;&#9;&#9;throw new ArgumentOutOfRangeException(nameof(destinationIndex));&#10;&#9;&#9;&#9;if (count &lt; 0 || sourceIndex + count &gt; Length || destinationIndex + count &gt; destination.Length)&#10;&#9;&#9;&#9;&#9;throw new ArgumentOutOfRangeException(nameof(count));&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;content.WrittenSpan.Slice(sourceIndex, count).CopyTo(destination.AsSpan(destinationIndex));&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Collections.Immutable;&#10;using System.ComponentModel;&#10;using System.Globalization;&#10;using System.Runtime.CompilerServices;&#10;using System.Text;&#10;using Microsoft.CodeAnalysis;&#10;using Microsoft.CodeAnalysis.Text;&#10;using System.Threading;&#10;&#10;namespace SourceGen.Utilities.Helpers;&#10;&#10;/// &lt;summary&gt;&#10;/// A helper type to build sequences of values with pooled buffers.&#10;/// &lt;/summary&gt;&#10;public sealed class IndentedCodeWriter : IDisposable&#10;{&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// The default indentation (tab).&#10;&#9;/// &lt;/summary&gt;&#10;&#9;private const string DefaultIndentation = &quot;\t&quot;;&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// The default new line (&lt;c&gt;'\n'&lt;/c&gt;).&#10;&#9;/// &lt;/summary&gt;&#10;&#9;private const char DefaultNewLine = '\n';&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// The &lt;see cref=&quot;ImmutableArrayBuilder{T}&quot;/&gt; instance that text will be written to.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;private ImmutableArrayBuilder&lt;char&gt; _builder;&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// The current indentation level.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;private int _currentIndentationLevel;&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// The current indentation, as text.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;private string _currentIndentation = String.Empty;&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// The cached array of available indentations, as text.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;private string[] _availableIndentations;&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Creates a new &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; object.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;public IndentedCodeWriter()&#10;&#9;{&#10;&#9;&#9;_builder = new ImmutableArrayBuilder&lt;char&gt;();&#10;&#9;&#9;_currentIndentationLevel = 0;&#10;&#9;&#9;_currentIndentation = String.Empty;&#10;&#9;&#9;_availableIndentations = new string[4];&#10;&#9;&#9;_availableIndentations[0] = String.Empty;&#10;&#10;&#9;&#9;for (int i = 1, n = _availableIndentations.Length; i &lt; n; i++)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_availableIndentations[i] = _availableIndentations[i - 1] + DefaultIndentation;&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Advances the current writer and gets a &lt;see cref=&quot;Span{T}&quot;/&gt; to the requested memory area.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;requestedSize&quot;&gt;The requested size to advance by.&lt;/param&gt;&#10;&#9;/// &lt;returns&gt;A &lt;see cref=&quot;Span{T}&quot;/&gt; to the requested memory area.&lt;/returns&gt;&#10;&#9;/// &lt;remarks&gt;&#10;&#9;/// No other data should be written to the writer while the returned &lt;see cref=&quot;Span{T}&quot;/&gt;&#10;&#9;/// is in use, as it could invalidate the memory area wrapped by it, if resizing occurs.&#10;&#9;/// &lt;/remarks&gt;&#10;&#9;public Span&lt;char&gt; Advance(int requestedSize)&#10;&#9;{&#10;&#9;&#9;// Add the leading whitespace if needed (same as WriteRawText below)&#10;&#9;&#9;if (_builder.Count == 0 || _builder.WrittenSpan[^1] == DefaultNewLine)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_builder.AddRange(_currentIndentation.AsSpan());&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return _builder.Advance(requestedSize);&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Increases the current indentation level.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;public void IncreaseIndent()&#10;&#9;{&#10;&#9;&#9;_currentIndentationLevel++;&#10;&#10;&#9;&#9;if (_currentIndentationLevel == _availableIndentations.Length)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Array.Resize(ref _availableIndentations, _availableIndentations.Length * 2);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Set both the current indentation and the current position in the indentations&#10;&#9;&#9;// array to the expected indentation for the incremented level (ie. one level more).&#10;&#9;&#9;_currentIndentation = _availableIndentations[_currentIndentationLevel]&#10;&#9;&#9;&#9;??= _availableIndentations[_currentIndentationLevel - 1] + DefaultIndentation;&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Decreases the current indentation level.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;public void DecreaseIndent()&#10;&#9;{&#10;&#9;&#9;_currentIndentationLevel--;&#10;&#9;&#9;_currentIndentation = _availableIndentations[_currentIndentationLevel];&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes a block to the underlying buffer.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;start&quot;&gt;The opening string to use for the block.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;end&quot;&gt;The closing string to use for the block.&lt;/param&gt;&#10;&#9;/// &lt;returns&gt;A &lt;see cref=&quot;Block&quot;/&gt; value to close the open block with.&lt;/returns&gt;&#10;&#9;public Block WriteBlock(string start = &quot;{&quot;, string end = &quot;}&quot;)&#10;&#9;{&#10;&#9;&#9;WriteLine(start);&#10;&#9;&#9;IncreaseIndent();&#10;&#10;&#9;&#9;return new Block(this, end);&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;content&quot;&gt;The content to write.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;isMultiline&quot;&gt;Whether the input content is multiline.&lt;/param&gt;&#10;&#9;public void Write(string content, bool isMultiline = false)&#10;&#9;{&#10;&#9;&#9;Write(content.AsSpan(), isMultiline);&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;content&quot;&gt;The content to write.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;isMultiline&quot;&gt;Whether the input content is multiline.&lt;/param&gt;&#10;&#9;public void Write(ReadOnlySpan&lt;char&gt; content, bool isMultiline = false)&#10;&#9;{&#10;&#9;&#9;if (isMultiline)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;while (content.Length &gt; 0)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;var newLineIndex = content.IndexOf(DefaultNewLine);&#10;&#10;&#9;&#9;&#9;&#9;if (newLineIndex &lt; 0)&#10;&#9;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;&#9;// There are no new lines left, so the content can be written as a single line&#10;&#9;&#9;&#9;&#9;&#9;WriteRawText(content);&#10;&#10;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;var line = content[..newLineIndex];&#10;&#10;&#9;&#9;&#9;&#9;// Write the current line (if it's empty, we can skip writing the text entirely).&#10;&#9;&#9;&#9;&#9;// This ensures that raw multiline string literals with blank lines don't have&#10;&#9;&#9;&#9;&#9;// extra whitespace at the start of those lines, which would otherwise happen.&#10;&#9;&#9;&#9;&#9;WriteIf(!line.IsEmpty, line);&#10;&#9;&#9;&#9;&#9;WriteLine();&#10;&#10;&#9;&#9;&#9;&#9;// Move past the new line character (the result could be an empty span)&#10;&#9;&#9;&#9;&#9;content = content[(newLineIndex + 1)..];&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;else&#10;&#9;&#9;{&#10;&#9;&#9;&#9;WriteRawText(content);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;handler&quot;&gt;The interpolated string handler with content to write.&lt;/param&gt;&#10;&#9;public void Write([InterpolatedStringHandlerArgument(&quot;&quot;)] ref WriteInterpolatedStringHandler handler)&#10;&#9;{&#10;&#9;&#9;_ = this;&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer depending on an input condition.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;condition&quot;&gt;The condition to use to decide whether or not to write content.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;content&quot;&gt;The content to write.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;isMultiline&quot;&gt;Whether the input content is multiline.&lt;/param&gt;&#10;&#9;public void WriteIf(bool condition, string content, bool isMultiline = false)&#10;&#9;{&#10;&#9;&#9;if (condition)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Write(content.AsSpan(), isMultiline);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer depending on an input condition.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;condition&quot;&gt;The condition to use to decide whether or not to write content.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;content&quot;&gt;The content to write.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;isMultiline&quot;&gt;Whether the input content is multiline.&lt;/param&gt;&#10;&#9;public void WriteIf(bool condition, ReadOnlySpan&lt;char&gt; content, bool isMultiline = false)&#10;&#9;{&#10;&#9;&#9;if (condition)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Write(content, isMultiline);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer depending on an input condition.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;condition&quot;&gt;The condition to use to decide whether or not to write content.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;handler&quot;&gt;The interpolated string handler with content to write.&lt;/param&gt;&#10;&#9;public void WriteIf(bool condition, [InterpolatedStringHandlerArgument(&quot;&quot;, nameof(condition))] ref WriteIfInterpolatedStringHandler handler)&#10;&#9;{&#10;&#9;&#9;_ = this;&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes a line to the underlying buffer.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;skipIfPresent&quot;&gt;Indicates whether to skip adding the line if there already is one.&lt;/param&gt;&#10;&#9;public void WriteLine(bool skipIfPresent = false)&#10;&#9;{&#10;&#9;&#9;if (skipIfPresent &amp;&amp; _builder.WrittenSpan is [ .., '\n', '\n' ])&#10;&#9;&#9;{&#10;&#9;&#9;&#9;return;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;_builder.Add(DefaultNewLine);&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer and appends a trailing new line.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;content&quot;&gt;The content to write.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;isMultiline&quot;&gt;Whether the input content is multiline.&lt;/param&gt;&#10;&#9;public void WriteLine(string content, bool isMultiline = false)&#10;&#9;{&#10;&#9;&#9;WriteLine(content.AsSpan(), isMultiline);&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer and appends a trailing new line.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;content&quot;&gt;The content to write.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;isMultiline&quot;&gt;Whether the input content is multiline.&lt;/param&gt;&#10;&#9;public void WriteLine(ReadOnlySpan&lt;char&gt; content, bool isMultiline = false)&#10;&#9;{&#10;&#9;&#9;Write(content, isMultiline);&#10;&#9;&#9;WriteLine();&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer and appends a trailing new line.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;handler&quot;&gt;The interpolated string handler with content to write.&lt;/param&gt;&#10;&#9;public void WriteLine([InterpolatedStringHandlerArgument(&quot;&quot;)] ref WriteInterpolatedStringHandler handler)&#10;&#9;{&#10;&#9;&#9;WriteLine();&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes a line to the underlying buffer depending on an input condition.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;condition&quot;&gt;The condition to use to decide whether or not to write content.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;skipIfPresent&quot;&gt;Indicates whether to skip adding the line if there already is one.&lt;/param&gt;&#10;&#9;public void WriteLineIf(bool condition, bool skipIfPresent = false)&#10;&#9;{&#10;&#9;&#9;if (condition)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;WriteLine(skipIfPresent);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer and appends a trailing new line depending on an input condition.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;condition&quot;&gt;The condition to use to decide whether or not to write content.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;content&quot;&gt;The content to write.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;isMultiline&quot;&gt;Whether the input content is multiline.&lt;/param&gt;&#10;&#9;public void WriteLineIf(bool condition, string content, bool isMultiline = false)&#10;&#9;{&#10;&#9;&#9;if (condition)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;WriteLine(content.AsSpan(), isMultiline);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer and appends a trailing new line depending on an input condition.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;condition&quot;&gt;The condition to use to decide whether or not to write content.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;content&quot;&gt;The content to write.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;isMultiline&quot;&gt;Whether the input content is multiline.&lt;/param&gt;&#10;&#9;public void WriteLineIf(bool condition, ReadOnlySpan&lt;char&gt; content, bool isMultiline = false)&#10;&#9;{&#10;&#9;&#9;if (condition)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Write(content, isMultiline);&#10;&#9;&#9;&#9;WriteLine();&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes content to the underlying buffer and appends a trailing new line depending on an input condition.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;condition&quot;&gt;The condition to use to decide whether or not to write content.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;handler&quot;&gt;The interpolated string handler with content to write.&lt;/param&gt;&#10;&#9;public void WriteLineIf(bool condition, [InterpolatedStringHandlerArgument(&quot;&quot;, nameof(condition))] ref WriteIfInterpolatedStringHandler handler)&#10;&#9;{&#10;&#9;&#9;if (condition)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;WriteLine();&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;inheritdoc/&gt;&#10;&#9;public override string ToString()&#10;&#9;{&#10;&#9;&#9;return _builder.WrittenSpan.Trim().ToString();&#10;&#9;}&#10;&#9;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Creates a &lt;see cref=&quot;SourceText&quot;/&gt; instance from the current content of the writer.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;returns&gt;A &lt;see cref=&quot;SourceText&quot;/&gt; instance containing the written content.&lt;/returns&gt;&#10;&#9;public SourceText ToSourceText()&#10;&#9;{&#10;&#9;&#9;return new IndentedCodeWriterSourceText(_builder, Encoding.UTF8);&#10;&#9;}&#10;&#10;&#9;/// &lt;inheritdoc/&gt;&#10;&#9;public void Dispose()&#10;&#9;{&#10;&#9;&#9;_builder.Dispose();&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Writes raw text to the underlying buffer, adding leading indentation if needed.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;content&quot;&gt;The raw text to write.&lt;/param&gt;&#10;&#9;private void WriteRawText(ReadOnlySpan&lt;char&gt; content)&#10;&#9;{&#10;&#9;&#9;if (_builder.Count == 0 || _builder.WrittenSpan[^1] == DefaultNewLine)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_builder.AddRange(_currentIndentation.AsSpan());&#10;&#9;&#9;}&#10;&#10;&#9;&#9;_builder.AddRange(content);&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// A delegate representing a callback to write data into an &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; instance.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;typeparam name=&quot;T&quot;&gt;The type of data to use.&lt;/typeparam&gt;&#10;&#9;/// &lt;param name=&quot;value&quot;&gt;The input data to use to write into &lt;paramref name=&quot;writer&quot;/&gt;.&lt;/param&gt;&#10;&#9;/// &lt;param name=&quot;writer&quot;&gt;The &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; instance to write into.&lt;/param&gt;&#10;&#9;public delegate void Callback&lt;in T&gt;(T value, IndentedCodeWriter writer);&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Represents an indented block that needs to be closed.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;/// &lt;param name=&quot;writer&quot;&gt;The input &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; instance to wrap.&lt;/param&gt;&#10;&#9;public struct Block(IndentedCodeWriter writer, string ending) : IDisposable&#10;&#9;{&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// The &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; instance to write to.&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;private IndentedCodeWriter? _writer = writer;&#10;&#10;&#9;&#9;/// &lt;inheritdoc/&gt;&#10;&#9;&#9;public void Dispose()&#10;&#9;&#9;{&#10;&#9;&#9;&#9;var writer = _writer;&#10;&#10;&#9;&#9;&#9;_writer = null;&#10;&#10;&#9;&#9;&#9;if (writer is not null)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;writer.DecreaseIndent();&#10;&#9;&#9;&#9;&#9;writer.WriteLine(ending);&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Provides a handler used by the language compiler to append interpolated strings into &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; instances.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;[EditorBrowsable(EditorBrowsableState.Never)]&#10;&#9;[InterpolatedStringHandler]&#10;&#9;public readonly ref struct WriteInterpolatedStringHandler&#10;&#9;{&#10;&#9;&#9;/// &lt;summary&gt;The associated &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; to which to append.&lt;/summary&gt;&#10;&#9;&#9;private readonly IndentedCodeWriter _writer;&#10;&#10;&#9;&#9;/// &lt;summary&gt;Creates a handler used to append an interpolated string into a &lt;see cref=&quot;StringBuilder&quot;/&gt;.&lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;literalLength&quot;&gt;The number of constant characters outside of interpolation expressions in the interpolated string.&lt;/param&gt;&#10;&#9;&#9;/// &lt;param name=&quot;formattedCount&quot;&gt;The number of interpolation expressions in the interpolated string.&lt;/param&gt;&#10;&#9;&#9;/// &lt;param name=&quot;writer&quot;&gt;The associated &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; to which to append.&lt;/param&gt;&#10;&#9;&#9;/// &lt;remarks&gt;This is intended to be called only by compiler-generated code. Arguments are not validated as they'd otherwise be for members intended to be used directly.&lt;/remarks&gt;&#10;&#9;&#9;public WriteInterpolatedStringHandler(int literalLength, int formattedCount, IndentedCodeWriter writer)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_writer = writer;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;Writes the specified string to the handler.&lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;value&quot;&gt;The string to write.&lt;/param&gt;&#10;&#9;&#9;public void AppendLiteral(string value)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_writer.Write(value);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;Writes the specified value to the handler.&lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;value&quot;&gt;The value to write.&lt;/param&gt;&#10;&#9;&#9;public void AppendFormatted(string? value)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;AppendFormatted&lt;string?&gt;(value);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;Writes the specified character span to the handler.&lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;value&quot;&gt;The span to write.&lt;/param&gt;&#10;&#9;&#9;public void AppendFormatted(ReadOnlySpan&lt;char&gt; value)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_writer.Write(value);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;Writes the specified value to the handler.&lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;value&quot;&gt;The value to write.&lt;/param&gt;&#10;&#9;&#9;/// &lt;typeparam name=&quot;T&quot;&gt;The type of the value to write.&lt;/typeparam&gt;&#10;&#9;&#9;public void AppendFormatted&lt;T&gt;(T value)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;if (value is not null)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;_writer.Write(value.ToString());&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;Writes the specified value to the handler.&lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;value&quot;&gt;The value to write.&lt;/param&gt;&#10;&#9;&#9;/// &lt;param name=&quot;format&quot;&gt;The format string.&lt;/param&gt;&#10;&#9;&#9;/// &lt;typeparam name=&quot;T&quot;&gt;The type of the value to write.&lt;/typeparam&gt;&#10;&#9;&#9;public void AppendFormatted&lt;T&gt;(T value, string? format)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;if (value is IFormattable formattable)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;_writer.Write(formattable.ToString(format, CultureInfo.InvariantCulture));&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;else if (value is not null)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;_writer.Write(value.ToString());&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;Writes the specified parameter name to the handler.&lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;parameter&quot;&gt;The parameter symbol to write.&lt;/param&gt;&#10;&#9;&#9;public void AppendFormatted(IParameterSymbol parameter)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_writer.Write(parameter.Name);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Writes the specified parameter names to the handler.&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;parameters&quot;&gt;The parameter symbols to write.&lt;/param&gt;&#10;&#9;&#9;public void AppendFormatted(ImmutableArray&lt;IParameterSymbol&gt; parameters)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;for (var i = 0; i &lt; parameters.Length; i++)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;_writer.Write(parameters[i].Name);&#10;&#10;&#9;&#9;&#9;&#9;if (i &lt; parameters.Length - 1)&#10;&#9;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;&#9;_writer.Write(&quot;, &quot;);&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// Provides a handler used by the language compiler to conditionally append interpolated strings into &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; instances.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;[EditorBrowsable(EditorBrowsableState.Never)]&#10;&#9;[InterpolatedStringHandler]&#10;&#9;public readonly ref struct WriteIfInterpolatedStringHandler&#10;&#9;{&#10;&#9;&#9;/// &lt;summary&gt;The associated &lt;see cref=&quot;WriteInterpolatedStringHandler&quot;/&gt; to use.&lt;/summary&gt;&#10;&#9;&#9;private readonly WriteInterpolatedStringHandler _handler;&#10;&#10;&#9;&#9;/// &lt;summary&gt;Creates a handler used to append an interpolated string into a &lt;see cref=&quot;StringBuilder&quot;/&gt;.&lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;literalLength&quot;&gt;The number of constant characters outside of interpolation expressions in the interpolated string.&lt;/param&gt;&#10;&#9;&#9;/// &lt;param name=&quot;formattedCount&quot;&gt;The number of interpolation expressions in the interpolated string.&lt;/param&gt;&#10;&#9;&#9;/// &lt;param name=&quot;writer&quot;&gt;The associated &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; to which to append.&lt;/param&gt;&#10;&#9;&#9;/// &lt;param name=&quot;condition&quot;&gt;The condition to use to decide whether or not to write content.&lt;/param&gt;&#10;&#9;&#9;/// &lt;param name=&quot;shouldAppend&quot;&gt;A value indicating whether formatting should proceed.&lt;/param&gt;&#10;&#9;&#9;/// &lt;remarks&gt;This is intended to be called only by compiler-generated code. Arguments are not validated as they'd otherwise be for members intended to be used directly.&lt;/remarks&gt;&#10;&#9;&#9;public WriteIfInterpolatedStringHandler(int literalLength, int formattedCount, IndentedCodeWriter writer, bool condition, out bool shouldAppend)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;if (condition)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;_handler = new WriteInterpolatedStringHandler(literalLength, formattedCount, writer);&#10;&#10;&#9;&#9;&#9;&#9;shouldAppend = true;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;else&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;_handler = default;&#10;&#10;&#9;&#9;&#9;&#9;shouldAppend = false;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;inheritdoc cref=&quot;WriteInterpolatedStringHandler.AppendLiteral(string)&quot;/&gt;&#10;&#9;&#9;public void AppendLiteral(string value)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_handler.AppendLiteral(value);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;inheritdoc cref=&quot;WriteInterpolatedStringHandler.AppendFormatted(string?)&quot;/&gt;&#10;&#9;&#9;public void AppendFormatted(string? value)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_handler.AppendFormatted(value);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;inheritdoc cref=&quot;WriteInterpolatedStringHandler.AppendFormatted(ReadOnlySpan{char})&quot;/&gt;&#10;&#9;&#9;public void AppendFormatted(ReadOnlySpan&lt;char&gt; value)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_handler.AppendFormatted(value);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;inheritdoc cref=&quot;WriteInterpolatedStringHandler.AppendFormatted{T}(T)&quot;/&gt;&#10;&#9;&#9;public void AppendFormatted&lt;T&gt;(T value)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_handler.AppendFormatted(value);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;inheritdoc cref=&quot;WriteInterpolatedStringHandler.AppendFormatted{T}(T, string?)&quot;/&gt;&#10;&#9;&#9;public void AppendFormatted&lt;T&gt;(T value, string? format)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_handler.AppendFormatted(value, format);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;inheritdoc cref=&quot;WriteInterpolatedStringHandler.AppendFormatted(IParameterSymbol)&quot;/&gt;&#10;&#9;&#9;public void AppendFormatted(IParameterSymbol parameter)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_handler.AppendFormatted(parameter);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;inheritdoc cref=&quot;WriteInterpolatedStringHandler.AppendFormatted(ImmutableArray{IParameterSymbol})&quot;/&gt;&#10;&#9;&#9;public void AppendFormatted(ImmutableArray&lt;IParameterSymbol&gt; parameters)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_handler.AppendFormatted(parameters);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/// &lt;summary&gt;&#10;&#9;/// A specialized &lt;see cref=&quot;SourceText&quot;/&gt; implementation optimized for &lt;see cref=&quot;IndentedCodeWriter&quot;/&gt; content.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;private sealed class IndentedCodeWriterSourceText(ImmutableArrayBuilder&lt;char&gt; content, Encoding encoding) : SourceText&#10;&#9;{&#10;&#9;&#9;public override Encoding Encoding =&gt; encoding;&#10;&#10;&#9;&#9;public override int Length =&gt; content.Count;&#10;&#10;&#9;&#9;public override char this[int position]&#10;&#9;&#9;{&#10;&#9;&#9;&#9;get&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;if (position &lt; 0 || position &gt;= Length)&#10;&#9;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;&#9;throw new ArgumentOutOfRangeException(nameof(position));&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;return content.WrittenSpan[position];&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;public override string ToString()&#10;&#9;&#9;{&#10;&#9;&#9;&#9;return content.WrittenSpan.ToString();&#10;&#9;&#9;}&#10;&#10;&#9;&#9;public override string ToString(TextSpan span)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;if (span.Start &lt; 0 || span.Start &gt; Length || span.End &gt; Length)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;throw new ArgumentOutOfRangeException(nameof(span));&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;return content.WrittenSpan.Slice(span.Start, span.Length).ToString();&#10;&#9;&#9;}&#10;&#10;&#9;&#9;public override void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;if (sourceIndex &lt; 0 || sourceIndex &gt; Length)&#10;&#9;&#9;&#9;&#9;throw new ArgumentOutOfRangeException(nameof(sourceIndex));&#10;&#9;&#9;&#9;if (destinationIndex &lt; 0 || destinationIndex &gt; destination.Length)&#10;&#9;&#9;&#9;&#9;throw new ArgumentOutOfRangeException(nameof(destinationIndex));&#10;&#9;&#9;&#9;if (count &lt; 0 || sourceIndex + count &gt; Length || destinationIndex + count &gt; destination.Length)&#10;&#9;&#9;&#9;&#9;throw new ArgumentOutOfRangeException(nameof(count));&#10;&#10;&#9;&#9;&#9;content.WrittenSpan.Slice(sourceIndex, count).CopyTo(destination.AsSpan(destinationIndex));&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>